# Producer-Consumer Problem in C using Pthreads

這是一個使用 POSIX Threads (`pthread`) 函式庫來解決經典「生產者-消費者問題」的 C 語言實作。

## 程式描述

此程式創建了兩個執行緒：
1.  **生產者 (Producer)**：負責生成資料（在此範例中是從 1 開始的整數），並將其放入一個共享的緩衝區。
2.  **消費者 (Consumer)**：負責從共享緩衝區中取出資料並「消費」它（在此範例中是將其印出）。

程式透過一個固定大小的環形緩衝區 (circular buffer) 來讓兩個執行緒進行通訊，並使用簡單的輪詢 (polling) 與 `sleep()` 機制來處理緩衝區滿或空的情況。

## 運作原理

- **共享緩衝區 (Shared Buffer)**：
  - 一個名為 `buffer` 的整數陣列，其大小由 `BUFFER_SIZE` (設為 7) 定義。
  - `in` 索引：指向生產者下一個要放入資料的位置。
  - `out` 索引：指向消費者下一個要取出資料的位置。
  - 此緩衝區被實作為一個環形佇列 (circular queue)。

- **生產者執行緒 (`producer`)**：
  - 進入一個無限迴圈，不斷生產新的整數。
  - 在生產前，它會檢查緩衝區是否已滿 (`(in + 1) % BUFFER_SIZE == out`)。
  - 如果已滿，它會印出 "Buffer is full, waiting..." 並暫停 1 秒，等待消費者取走資料。
  - 如果有空間，它會將生產的資料放入 `buffer[in]`，並更新 `in` 索引。

- **消費者執行緒 (`consumer`)**：
  - 進入一個無限迴圈，不斷嘗試消費資料。
  - 在消費前，它會檢查緩衝區是否為空 (`in == out`)。
  - 如果為空，它會印出 "Buffer is empty, waiting..." 並暫停 1 秒，等待生產者放入資料。
  - 如果有資料，它會從 `buffer[out]` 取出資料，並更新 `out` 索引。

- **同步機制 (Synchronization)**：
  - 這個範例使用了一種稱為「忙碌等待」(Busy-Waiting) 的基本同步方法。執行緒在無法繼續工作時，會進入一個迴圈並短暫睡眠 (`sleep(1)`)，然後再次檢查條件。
  - **注意**：這是一種比較簡易但效率較低的同步方式。在更複雜或對效能要求更高的應用中，通常會使用互斥鎖 (Mutex) 和條件變數 (Condition Variables) 來避免不必要的 CPU 資源浪費，並實現更精確的執行緒喚醒機制。

## 如何編譯與執行

您需要一個 C 語言編譯器 (例如 GCC) 和支援 POSIX Threads 的環境 (如 Linux 或 macOS)。

1.  **編譯程式碼**：
    打開終端機，使用以下指令進行編譯。`-pthread` 旗標是必須的，用來連結 `pthread` 函式庫。
    ```bash
    gcc queue.c -o queue -pthread
    ```

2.  **執行程式**：
    ```bash
    ./queue
    ```

3.  **預期輸出**：
    您將會看到生產者和消費者的輸出交錯出現，顯示它們如何分別向緩衝區存入和取出數字。當緩衝區滿或空時，會顯示對應的等待訊息。
    ```
    Produced: 1
    Consumed: 1
    Produced: 2
    Consumed: 2
    ...
    ```

## 程式碼細節

- **`BUFFER_SIZE`**: 定義緩衝區的大小，設為 `7`。
- **`buffer[]`**: 全域變數，作為共享緩衝區。
- **`in`, `out`**: 全域變數，用於追蹤緩衝區的頭尾索引。
- **`producer(void *param)`**: 生產者執行緒的進入點函式。
- **`consumer(void *param)`**: 消費者執行緒的進入點函式。
- **`main()`**: 主函式，負責初始化並創建兩個執行緒。
